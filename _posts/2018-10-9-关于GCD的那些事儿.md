---
layout: post
title: "关于GCD的那些事儿"
author: "骆小喵"
categories: learning
tags: [learning]
feature-img: "assets/img/article/gcd.jpg"
thumbnail: "assets/img/article/gcd.jpg"
---

## 1. 遇到的问题
在项目中经常会遇到这样的问题，一个页面由于内容繁多，结构复杂，后台写了5个接口进行支持，这5个接口互相又没有什么影响，也没什么顺序，但是就是需要把这5个接口的数据全都拿到之后组合一下然后刷新页面。

不妨举一个🌰子来说明一下，假如现在有5个魔法碎片散落在世界各处，我们需要把他们全都找到之后拼在一起就可以召唤神龙，然后就可以一夜暴富，荣登福布斯，迎娶白富美，走上人生巅峰（好了，不要YY了）。那么我们怎么去找这5个魔法碎片呢，现在能想到的就是有两种办法，一种是派一个人去找，找到1个碎片回来报到，再找下一个，直到找到5个。还有一种方法是派5个人一起去找，5个人中有1个人找到就回来报到，直到5个人都依次找到并回来报到。

这两种方法中明显第二种需要的时间更少，效率更高，我们在项目中也是，五个请求要是一个一个嵌套起来去处理，显然会很慢，很耗时间，不会被产品打死，也会被用户骂死，显然这种方式不可取，所以我们主要来谈一下怎么更好的用第二种方法来实现需求，在iOS里面GCD技术正好可以解决这种问题，当然也有其他方式，只是GCD用起来代码更简洁，实现更优雅，逼格更高一点。

### 1.1 解决方法
说到用GCD来解决，其实也有很多解决方法，我们先来说一种解决方法
```
//获取一下系统提供的全局队列
dispatch_queue_t queue =  dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);

//新建一个组
dispatch_group_t group = dispatch_group_create();

dispatch_group_async(group, queue, ^{
        
    //创建一个计数信号Dispatch Semaphore 初始值设为0
    dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);
        
    //发起第一个网络请求 
    //由于网络请求框架大都是异步请求，所以我们可以写一个异步任务来简单模拟一下网络请求
    //以下代码只是进行了一个异步的网络请求模拟
    dispatch_async(queue, ^{
        
        //sleep 10秒模拟一下网络延迟
        sleep(10);
        //假设这里已经开始回调执行完成
        NSLog(@"网络请求1,执行完成");
            
        //将Dispatch Semaphore计数信号值加1 这个要写到网络请求的回调里，无论成功失败。
        dispatch_semaphore_signal(semaphore);
    });
        
    //一直等待，直到Dispatch Semaphore的计数值达到大于等于1
    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
});


.
.
. /* 中间三个请求是一模一样的，所以就先省略。 */
.
.


dispatch_group_async(group, queue, ^{
        
    dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);
        
    //发起第5个网络请求 
    dispatch_async(queue, ^{
        sleep(10);
        NSLog(@"网络请求5,执行完成");
        dispatch_semaphore_signal(semaphore);
    });
        
    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
});


//全部执行结束
dispatch_group_notify(group, queue, ^{
    NSLog(@"请求全部执行结束");
});

```
以上就是GCD异步并发实现五个请求的一种方法。

下面我们解释一下这种方法为什么要这么写，实现原理，以及各个GCD中函数的含义及用法。

## 2.GCD的API

### 2.1 什么是Dispatch Queue
Dispatch Queue就是执行处理的等待队列。程序猿们通过```dispatch_async```等一些函数API在Block中写一些自己想执行的代码，并追加的Dispatch Queue中。然后Dispatch Queue按照追加的顺序（学术用语先进先出FIFO）执行处理。  


执行处理时存在两种Dispatch Queue，一种是串行队列Serial Dispatch Queue，一种是并行队列Concurrent Dispatch Queue。

### 2.2. 如何得到一个Dispatch Queue
得到Dispatch Queue有两种方法，一种是通过GCD的API生成，另一种是获取系统标准提供的Dispatch Queue。
#### 2.2.1 通过GCD的API生成
通过``` dispatch_queue_create ```函数可生成Dispatch Queue。
* 生成一个Serial Dispatch串行队列
```
dispatch_queue_t mySerialDispatchQueue = dispatch_queue_create("cc.omiao.gcd.mySerialDispacthQueue", NULL);
```
该函数的第一个参数指定串行队列的名称，例如上面的例子，Dispatch Queue的名称推荐使用应用程序的ID这种逆序全程域名，这样命名简单易懂，方便调试，当然你也可以设为NULL，不过调试的一脸懵逼，就会后悔为啥没有起一个好名字，哈哈哈哈。第二个参数指定为NULL,当然你也可以设DISPATCH_QUEUE_SERIAL不过没什么意义，本身DISPATCH_QUEUE_SERIAL就是NULL，不信看API啊。

* 生成一个Concurrent Dispatch Queue 并行队列
```
 dispatch_queue_t myConcurrentDispatchQueue = dispatch_queue_create("cc.omiao.gcd.myConcurrentDispatchQueue", DISPATCH_QUEUE_CONCURRENT);
```
生成并行队列的时候第一个参数同上，第二个参数必须写DISPATCH_QUEUE_CONCURRENT。

#### 2.2.2 获取系统标准提供的Dispatch Queue
实际上呢，也不用特意去生成Dispatch Queue，系统会给我们提供几个，比如Main Dispatch Queue和Global Dispatch Queue。


Main Dispatch Queue是在主线程执行的队列，因为主线程只有1个，所以Main Dispatch Queue是Serial Dispatch Queue串行队列。


而Global Dispatch Queue是所有应用程序都能使用的Concurrent Dispatch Queue，一般没必要通过函数```dispatch_queue_create```逐个生成Concurrent Dispatch Queue。只要获取一下系统提供的Global Dispatch Queue使用即可。另外呢Global 待续。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。

系统提供的Dispatch Queue总结如下表所示。


|名称|种类|说明|
|:-----|:-------|:-----|
|Main Dispatch Queue | Serial Dispatch Queue|主线程执行|
|Global Dispatch Queue(High Priority) | Concurrent Dispatch queue|执行优先级：高（最高优先）|
|Global Dispatch Queue(Default Priority) | Concurrent Dispatch queue|执行优先级：默认 |
|Global Dispatch Queue(Low Priority) | Concurrent Dispatch queue|执行优先级：低 |
|Global Dispatch Queue(Background Priority) | Concurrent Dispatch queue|执行优先级：后台 |


各种Dispatch Queue 的获取方法如下。
```
/*
 *  Main Dispatch Queue 的获取方法
 */
dispatch_queue_t mainDispatchQueue = dispatch_get_main_queue();

/*
 *  Global Dispatch Queue (最高优先级)的获取方法
 */  
dispatch_queue_t globalDispatchQueueHigh = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0);
    
/*
 *  Global Dispatch Queue (默认优先级)的获取方法 
 */
dispatch_queue_t globalDispatchQueueDefault = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    
/*
 *  Global Dispatch Queue (低优先级)的获取方法 
 */
dispatch_queue_t globalDispatchQueueLow = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0);
    
/*
 *  Global Dispatch Queue (后台优先级)的获取方法 
 */
dispatch_queue_t globalDispatchQueueBackground = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0);

```





